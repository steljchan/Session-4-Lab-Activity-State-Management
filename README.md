Dalam mengerjakan project ini, saya belajar membedakan dua pendekatan utama dalam pengelolaan state di Flutter, yaitu Ephemeral State (StatefulWidget dengan setState) dan App State (menggunakan scoped_model). Keduanya memiliki fungsi yang sama, yaitu untuk menyimpan dan mengelola data yang berubah seiring jalannya aplikasi, tetapi tujuan, serta dampaknya terhadap arsitektur aplikasi sangat berbeda.

Pada bagian **Ephemeral State**, state disimpan langsung di dalam sebuah widget dengan memanfaatkan StatefulWidget dan fungsi setState(). Cara ini sederhana dan sangat efektif untuk project kecil, seperti menghitung nilai counter, menampilkan hasil input teks, atau mengatur toggle. Namun, saya juga menyadari keterbatasan besar dari pendekatan ini. Data yang disimpan hanya berlaku di dalam widget tersebut saja, sehingga tidak bisa diakses atau dibagikan ke widget lain, apalagi lintas halaman. Saat berpindah screen atau aplikasi direstart, state langsung hilang. Dari sini, saya memahami bahwa Ephemeral State cocok untuk kebutuhan sementara dan kecil, tetapi tidak dapat diandalkan jika aplikasi mulai bertumbuh besar.

Berbeda dengan itu, pada bagian App State dengan scoped_model, saya belajar pendekatan yang lebih terstruktur dan terpusat. State tidak lagi disimpan di dalam widget, melainkan dalam sebuah Model terpisah (CounterModel). Model ini kemudian dibungkus dengan ScopedModel di level aplikasi utama (MyApp), sehingga semua widget yang ada di dalamnya dapat mengakses dan menggunakan data tersebut. Saya juga mempelajari penggunaan ScopedModelDescendant untuk membaca state dari model dan memperbarui UI secara otomatis saat ada perubahan data melalui notifyListeners(). Pengalaman ketika menambahkan halaman kedua (SecondScreen) menjadi titik penting dalam pembelajaran ini. Saat saya menambah, mengurangi, atau mereset nilai counter di halaman kedua, perubahan tersebut langsung terlihat juga di halaman pertama. Hal ini menegaskan bahwa App State mampu menjaga konsistensi data lintas halaman, sesuatu yang tidak bisa dicapai dengan Ephemeral State.

Selain itu, saya juga belajar bahwa App State Management sangat penting dalam pengembangan aplikasi besar. Contoh nyata bisa dilihat pada user authentication (data login harus bisa diakses oleh semua halaman), shopping cart (keranjang belanja yang selalu sinkron di halaman produk, keranjang, dan checkout), serta pengaturan global (seperti dark mode atau bahasa aplikasi yang berlaku di semua screen). Dengan adanya App State, developer tidak perlu lagi meng-copy state antar widget secara manual, karena state sudah tersedia di tingkat aplikasi.

Dari segi kode, saya menyadari bahwa penggunaan Model, ScopedModel, dan ScopedModelDescendant memang menambah lapisan tambahan dibandingkan hanya memakai setState. Namun, tambahan kode ini justru membuat struktur aplikasi lebih jelas, lebih terorganisir, dan lebih mudah dikembangkan di masa depan. Saya belajar pentingnya pemisahan antara logic dan UI: model bertanggung jawab mengelola data dan logika, sementara widget hanya fokus menampilkan tampilan berdasarkan data tersebut.

Selama proses pengerjaan, saya sempat menghadapi beberapa error:
1. Ephemeral State Blank Page: Awalnya aplikasi hanya menampilkan blank page. Setelah dicek, ternyata file main.dart belum diubah sesuai instruksi, sehingga tidak ada widget yang benar-benar menampilkan counter. Solusinya adalah menuliskan ulang CounterWidget dengan StatefulWidget dan menambahkan logika setState. Blank page biasanya terjadi karena root widget belum dibangun dengan benar.
2. Error pada File Test (widget_test.dart) terjadi karena Flutter secara default membuat test dengan teks “You have pushed the button this many times”. Padahal, UI yang saya buat menggunakan teks berbeda seperti “Counter Value: 0”. Maka test harus diubah supaya sesuai dengan UI yang saya buat.
3. Saat mencoba menjalankan aplikasi app state, saya mendapat error karena ScopedModel tidak dikenali. Ternyata saya lupa menambahkan dependency scoped_model di pubspec.yaml. Setelah ditambahkan dan dijalankan flutter pub get, error langsung hilang. 
4. Ketika pertama kali menambahkan halaman kedua (SecondScreen), counter tidak terbawa ke halaman baru. Masalahnya ada karena saya belum membungkus MaterialApp dengan ScopedModel. Setelah diperbaiki, counter akhirnya sinkron di semua halaman. 

Meskipun scoped_model membantu memahami konsep App State, ternyata package ini sudah jarang digunakan dalam proyek Flutter modern. Framework yang lebih populer dan scalable seperti Provider atau Riverpod kini lebih banyak dipakai karena menawarkan fleksibilitas dan fitur yang lebih lengkap. Tetapi, mempelajari scoped_model tetap sangat bermanfaat karena untuk memahami dasar-dasar App State Management dengan lebih sederhana sebelum beralih ke solusi yang lebih kompleks.

Kesimpulan: Ephemeral State lebih cocok untuk kebutuhan sederhana dan terbatas pada satu widget, sedangkan App State sangat dibutuhkan saat aplikasi semakin kompleks dan memerlukan konsistensi data di berbagai widget atau halaman.
